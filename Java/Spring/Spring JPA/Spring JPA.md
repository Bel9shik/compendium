
	Под капотом использует Hibernate, а  Hibernate под капотом использует JDBC Template

было:
![[dao with hibernate.png]]

стало:
![[spring JPA example repository.png]]

### Отличие DAO от Репозитория

* Похожие понятия (и то, и другое для работы с данными)
* Репозиторий обычно более высокоуровневый, ближе к бизнес логике (не пишем SQL запросы, работаем с сущностями)
* DAO обычно более низкоуровневый, ближе к БД (можем писать SQL запросы)
* В сложных приложениях обычно есть и то, и другое. Репозиторий - для стандартных операций с данными (CRUD, например), DAO - для более сложных манипуляция с данными с БД, где обычно нужно вручную писать SQL

### Сервисный слой

![[service layer.png]]

Сервисный слой нужен для реализации бизнес-логики, чтобы сам контроллер не знал о работе с БД.

* В контроллере мы хотим иметь минимум кода. В идеале - только простейшая логика обработки запросов и ответов
* Любая работа с данными, полученными из БД должна лежать в **сервисном слое**. Здесь мы описываем бизнес логику нашего приложения, а в контроллере только вызываем нужные методы
* В один сервисный класс может быть внедрено несколько DAO, репозиториев
* Класс для сервисного слоя помечается аннотацией [[@Service]]

### Генерация запросов

Можно написать название метода в интерфейсе с JpaRepository и Spring JPA сам сгенерирует SQL запросы. Список синтаксиса, который распознаётся Spring JPA: https://docs.spring.io/spring-data/jpa/reference/jpa/query-methods.html


### Работа с датами

[[@Temporal]]  и [[@DateTimeFormat]]


### Проблема N + 1

![[N+1 problem.png]]

* N + 1 запросов к БД
* Если N большое, то приложение надолго зависнет
* Если хотим получить товары для нескольких людей - не страшно
* Если надо для всех - надо исправлять проблему N + 1
* FetchType.EAGER никак не поможет - все ранво будут делаться N запросов к таблице Item, только теперь сразу после загрузки людей
* Надо делать объединение таблиц (LEFT JOIN) и работать с объединённой таблицей (смотреть блок про БД)

![[solution N + 1 problem.png]]
Теперь сделан лишь 1 запрос к БД. Так как left join создаёт избыточную таблицу, то имеет смысл переделать запрос через создание Set (не забыть реализовать методы equals и hashCode в Person)