* Компонент Spring Framework
* Является стандартом для обеспечения безопаности в Spring приложениях
* Помогает реализовать функционал аутентификации и авторизации
* Может использоваться как в монолитных, так и в микросервисных приложениях

### Как Spring Security встраивается в приложение?

При помощи фильтров!

HTTP запрос --> Фильтры Security --> Spring приложение

**Фильтр** - объект, который перехватывает все входящие HTTP запросы 

### Как устроена аутентификация в Spring Security

[[Authentication]] и [[AuthenticationProvider]]

![[authentication spring security.png]]

#### После успешной аутентификации

AuthenticationТеперь каждый раз, когда пользователь будет делать запрос к нашему приложению, мы будем иметь доступ к его объекту [[Authentication]] (с Principal внутри)

Как это возможно? Объект помещается в сессию пользователя. За то, чтобы при каждом запросе этот объект подгружался из сессии отвечает отдельный фильтр Spring Security. Пока сессия пользователя действительна - можем получать объект [[Authentication]] и не заставлять пользователя проходить аутентификацию ещё раз.

## Сесии и Cookies

[[Session]] и [[Cookies]]

Cookies посылаются браузером при каждом запросе и если сессия с id находится, это означает, что пользователь аутентифицирован.

Из сессии мы получаем данные об этом пользователе (объект [[Authentication]]). Эти данные кладутся в поток текущего пользователя (ThreadLocal) и доступны только в этом потоке.
![[sessions and cookies.png]]

###  Как работают сессии?

* Клиент получает от сервера cookies с названием "JSESSIONID". Значение этого cookie - уникальный идентификатор пользователя
* По этому cookie сервер узнаёт пользователя и узнаёт его сессию
* Если очистить cookies в браузере, сервер больше не сможет узнать пользователя и его сессию

### Пример реализации Spring Security
Было
![[spring security example.png]]
стало:
![[springSecurity after.png]]

* В своих классах были реализованы стандартные интерфейсы Spring Security --> теперь Spring Security будет знать, как использовать наши классы
* Знает, какой методы вызвать в *сервисе*, чтобы получить пользователя по имени
* Знает, какие методы вызвать на пользователе, чтобы получить имя пользователя и пароль (и не только эти данные)

![[authenticationProvider examples.png]]

## Пароли
#### Без шифрования - плохо
* Если БД "утечет", все пароли окажутся в руках злоумышленников 
* Хранить пароли в исходном виде - неуважение к персональным данным пользователей
* Мы сами, как владельцы сервисы, не должны знать пароль от пользователя (в любом уважающем себя сервисе так и есть).
* Надо хранить только зашифрованную версию пароля

#### С шифрованием - хорошо

* Вариаций шифрования великое множество. Саме известные -  bcrypt и sha256

###  Авторизация

Как сейчас:

![[authenticate first.png]]
* Проверка правил идёт сверху вниз, первое совпашее паравило применяется
* Поэтому более специфичные правила должны стоять выше более общих


Хотим сделать, чтобы у каждой роли были свои права для получения страниц. Spring Security есть 2 способа ограничивать доступ:
1) Роли (должны начинаться на ROLE_, ибо именно такой синтаксис ждёт spring security)
2) Действия
![[roles vs autorities.png]]

Для Spring Security Role=Authority, но некоторые люди разделяют эти понятия
* **Role** - более общая единица определения доступа (контйнер для нескольких Authority)
* **Authority** - более мелкая единица определения доступа (конкретное действие)

Смотреть [[@PreAuthorize]]

