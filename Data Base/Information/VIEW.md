## CREATE VIEW

CREATE VIEW — создать представление

## Синтаксис

CREATE [ OR REPLACE ] [ TEMP | TEMPORARY ] [ RECURSIVE ] VIEW _`имя`_ [ ( _`имя_столбца`_ [, ...] ) ]
    [ WITH ( _`имя_параметра_представления`_ [= _`значение_параметра_представления`_] [, ... ] ) ]
    AS _`запрос`_
    [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]

## Описание

`CREATE VIEW` создаёт представление запроса. Создаваемое представление лишено физической материализации, поэтому указанный запрос будет выполняться при каждом обращении к представлению.

Команда `CREATE OR REPLACE VIEW` действует подобным образом, но если представление с этим именем уже существует, оно заменяется. Новый запрос должен выдавать те же столбцы, что выдавал запрос, ранее определённый для этого представления (то есть, столбцы с такими же именами должны иметь те же типы данных и следовать в том же порядке), но может добавить несколько новых столбцов в конце списка. Вычисления, в результате которых формируются столбцы представления, могут быть совершенно другими.

Если задано имя схемы (например, `CREATE VIEW myschema.myview ...`), представление создаётся в указанной схеме, в противном случае — в текущей. Временные представления существуют в специальной схеме, так что при создании таких представлений имя схемы задать нельзя. Имя представления должно отличаться от имён других представлений, таблиц, последовательностей, индексов или сторонних таблиц в этой схеме.

### Зачем нужны VIEW?

1. **Упрощение запросов**:
    
    - Сложные и длинные SQL-запросы можно сохранить в виде представления, чтобы в дальнейшем использовать их как обычные таблицы.
2. **Повышение читаемости кода**:
    
    - Упрощает сложные аналитические запросы, делая код более структурированным и понятным.
3. **Повышение безопасности**:
    
    - Можно скрыть сложные детали структуры базы данных от пользователей. Например, предоставить доступ к данным через представление, но не к самой таблице.
4. **Обеспечение консистентности данных**:
    
    - Если представление настроено на сложное вычисление или объединение данных из нескольких таблиц, вы гарантируете, что всегда будете получать актуальные данные.
5. **Переиспользование логики**:
    
    - Общие бизнес-правила или фильтры можно инкапсулировать в представлении и использовать в разных запросах.


### Преимущества использования VIEW

1. **Абстрагирование сложности**:
    
    - Пользователи могут обращаться к представлению как к простой таблице, не зная деталей запроса.
2. **Обновляемые данные**:
    
    - Данные в представлении всегда актуальны, так как они основаны на реальном запросе.
3. **Гибкость**:
    
    - Представление можно строить на основе любых SQL-запросов, включая объединение таблиц, агрегатные функции и фильтры.

---

### Недостатки VIEW

1. **Производительность**:
    
    - Обычные представления не хранят данные, а пересчитываются при каждом обращении, что может замедлять сложные запросы.
2. **Ограничения обновляемости**:
    
    - В некоторых случаях представления не могут быть обновлены напрямую (например, если используются агрегатные функции).

## Параметры

`TEMPORARY` или `TEMP`

С таким указанием представление создаётся как временное. Временные представления автоматически удаляются в конце сеанса. Существующее постоянное представление с тем же именем не будет видно в текущем сеансе, пока существует временное, однако к нему можно обратиться, дополнив имя указанием схемы.

Если в определении представления задействованы временные таблицы, представление так же создаётся как временное (вне зависимости от присутствия явного указания `TEMPORARY`).

`RECURSIVE`

Создаёт рекурсивное представление. Синтаксис

CREATE RECURSIVE VIEW [ _`схема`_ . ] _`имя`_ (_`имена_столбцов`_) AS SELECT _`...`_;

равнозначен

CREATE VIEW [ _`схема`_ . ] _`имя`_ AS WITH RECURSIVE _`имя`_ (_`имена_столбцов`_) AS (SELECT _`...`_) SELECT _`имена_столбцов`_ FROM _`имя`_;

Для рекурсивного представления обязательно должен задаваться список с именами столбцов.

_`имя`_

Имя создаваемого представления (возможно, дополненное схемой).

_`имя_столбца`_

Необязательный список имён, назначаемых столбцам представления. Если отсутствует, имена столбцов формируются из результатов запроса.

``WITH ( _`имя_параметра_представления`_ [= _`значение_параметра_представления`_] [, ... ] )``

В этом предложении могут задаваться следующие необязательные параметры представления:

`check_option` (`string`)

Этот параметр может принимать значение `local` (локально) или `cascaded` (каскадно) и равнозначен указанию `WITH [ CASCADED | LOCAL ] CHECK OPTION` (см. ниже). Изменить этот параметр у существующего представления с помощью [ALTER VIEW](https://postgrespro.ru/docs/postgresql/9.6/sql-alterview.html "ALTER VIEW") нельзя.

`security_barrier` (`boolean`)

Этот параметр следует использовать, если представление должно обеспечивать защиту на уровне строк. За дополнительными подробностями обратитесь к [Разделу 39.5](https://postgrespro.ru/docs/postgresql/9.6/rules-privileges.html "39.5. Правила и права").

_`запрос`_

Команда [SELECT](https://postgrespro.ru/docs/postgresql/9.6/sql-select.html "SELECT") или [VALUES](https://postgrespro.ru/docs/postgresql/9.6/sql-values.html "VALUES"), которая выдаёт столбцы и строки представления.

`WITH [ CASCADED | LOCAL ] CHECK OPTION`

Это указание управляет поведением автоматически изменяемых представлений. Если оно присутствует, при выполнении операций `INSERT` и `UPDATE` с этим представлением будет проверяться, удовлетворяют ли новые строки условию, определяющему представление (то есть, проверяется, будут ли новые строки видны через это представление). Если они не удовлетворяют условию, операция не будет выполнена. Если указание `CHECK OPTION` отсутствует, команды `INSERT` и `UPDATE` смогут создавать в этом представлении строки, которые не будут видны в нём. Поддерживаются следующие варианты проверки:

`LOCAL`

Новые строки проверяются только по условиям, определённым непосредственно в самом представлении. Любые условия, определённые в нижележащих базовых представлениях, не проверяются (если только в них нет указания `CHECK OPTION`).

`CASCADED`

Новые строки проверяются по условиям данного представления и всех нижележащих базовых. Если указано `CHECK OPTION`, а `LOCAL` и `CASCADED` опущено, подразумевается указание `CASCADED`.

Указание `CHECK OPTION` нельзя использовать с рекурсивными представлениями.

Заметьте, что `CHECK OPTION` поддерживается только для автоматически изменяемых представлений, не имеющих триггеров `INSTEAD OF` и правил `INSTEAD`. Если автоматически изменяемое представление определено поверх базового представления с триггерами `INSTEAD OF`, то для проверки ограничений автоматически изменяемого представления можно применить указание `LOCAL CHECK OPTION`, хотя условия базового представления с триггерами `INSTEAD OF` при этом проверяться не будут (каскадная проверка не будет спускаться к представлению, модифицируемому триггером, и любые параметры проверки, определённые для такого представления, будут просто игнорироваться). Если для представления или любого из его базовых отношений определено правило `INSTEAD`, приводящее к перезаписи команды `INSERT` или `UPDATE`, в перезаписанном запросе все параметры проверки будут игнорироваться, в том числе проверки автоматически изменяемых представлений, определённых поверх отношений с правилом `INSTEAD`.