## CREATE INDEX

CREATE INDEX — создать индекс

## Синтаксис

CREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] [ [ IF NOT EXISTS ] _`имя`_ ] ON _`имя_таблицы`_ [ USING _`метод`_ ]
    ( { _`имя_столбца`_ | ( _`выражение`_ ) } [ COLLATE _`правило_сортировки`_ ] [ _`класс_операторов`_ ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ] [, ...] )
    [ WITH ( _`параметр_хранения`_ [= _`значение`_] [, ... ] ) ]
    [ TABLESPACE _`табл_пространство`_ ]
    [ WHERE _`предикат`_ ]

### Зачем нужны индексы?

Индексы повышают производительность запросов за счет:

1. **Ускорения поиска**: Вместо полного сканирования таблицы (что медленно при большом объеме данных), PostgreSQL использует индекс для быстрого нахождения строк.
2. **Ускорения сортировки**: Индекс может заранее хранить данные в отсортированном виде, что ускоряет операции с `ORDER BY`.
3. **Ускорения соединений (`JOIN`)**: Если таблицы связываются по ключам (например, первичному или внешнему), индекс помогает ускорить эту операцию.
4. **Ускорения фильтрации (`WHERE`)**: Индекс используется для быстрого нахождения строк, соответствующих условиям фильтрации.

## Описание

`CREATE INDEX` создаёт индексы по указанному столбцу(ам) заданного отношения, которым может быть таблица или материализованное представление. Индексы применяются в первую очередь для *оптимизации производительности базы данных* (хотя при неправильном использовании возможен и противоположный эффект).

Ключевое поле для индекса задаётся как имя столбца или выражение, заключённое в скобки. Если метод индекса поддерживает составные индексы, допускается указание нескольких полей.

Поле индекса может быть выражением, вычисляемым из значений одного или нескольких столбцов в строке таблицы. Это может быть полезно для получения быстрого доступа к данным по некоторому преобразованию исходных значений. Например, индекс, построенный по выражению `upper(col)`, позволит использовать поиск по индексу в предложении `WHERE upper(col) = 'JIM'`.

PostgreSQL предоставляет следующие методы индексов: B-дерево, хеш, GiST, SP-GiST, GIN и BRIN. Пользователи могут определить и собственные методы индексов, но это довольно сложная задача.

Если в команде присутствует предложение `WHERE`, она создаёт _частичный индекс_. Такой индекс содержит записи только для части таблицы, обычно более полезной для индексации, чем остальная таблица. Например, если таблица содержит информацию об оплаченных и неоплаченных счетах, при этом последних сравнительно немного, но именно эта часть таблицы наиболее востребована, то увеличить быстродействие можно, создав индекс только по этой части. Ещё одно возможное применение `WHERE` — добавив `UNIQUE`, обеспечить уникальность в подмножестве таблицы. Подробнее это рассматривается в [Разделе 11.8](https://postgrespro.ru/docs/postgresql/9.6/indexes-partial.html "11.8. Частичные индексы").

Выражение в предложении `WHERE` может ссылаться только на столбцы нижележащей таблицы, но не обязательно ограничиваться теми, по которым строится индекс. В настоящее время в `WHERE` также нельзя использовать подзапросы и агрегатные выражения. Это же ограничение распространяется и на выражения в полях индексов.

Все функции и операторы, используемые в определении индекса, должны быть «постоянными», то есть, их результаты должны зависеть только от аргументов, но не от внешних факторов (например, содержимого другой таблицы или текущего времени). Это ограничение обеспечивает определённость поведения индекса. Чтобы использовать в выражении индекса или в предложении `WHERE` собственную функцию, не забудьте пометить её при создании как постоянную (IMMUTABLE).

## Параметры

`UNIQUE`

Указывает, что система должна контролировать повторяющиеся значения в таблице при создании индекса (если в таблице уже есть данные) и при каждом добавлении данных. Попытки вставить или изменить данные, при которых будет нарушена уникальность индекса, будут завершаться ошибкой.

`CONCURRENTLY`

С этим указанием PostgreSQL построит индекс, не устанавливая никаких блокировок, которые бы предотвращали добавление, изменение или удаление записей в таблице, тогда как по умолчанию операция построения индекса блокирует запись (но не чтение) данных в таблице до своего завершения. С созданием индекса в этом режиме связан ряд особенностей, о которых следует знать, — см. [Неблокирующее построение индексов](https://postgrespro.ru/docs/postgresql/9.6/sql-createindex#sql-createindex-concurrently "Неблокирующее построение индексов").

Для временных таблиц `CREATE INDEX` всегда выполняется более простым, неблокирующим способом, так как они не могут использоваться никакими другими сеансами.

`IF NOT EXISTS`

Не считать ошибкой, если индекс с таким именем уже существует. В этом случае будет выдано замечание. Заметьте, что нет никакой гарантии, что существующий индекс как-то соотносится с тем, который мог бы быть создан. Имя индекса является обязательным, когда указывается `IF NOT EXISTS`.

_`имя`_

Имя создаваемого индекса. Указание схемы при этом не допускается; индекс всегда относится к той же схеме, что и родительская таблица. Если имя опущено, PostgreSQL формирует подходящее имя по имени родительской таблицы и именам индексируемых столбцов.

_`имя_таблицы`_

Имя индексируемой таблицы (возможно, дополненное схемой).

_`метод`_

Имя применяемого метода индекса. Возможные варианты: `btree`, `hash`, `gist`, `spgist`, `gin` и `brin`. По умолчанию подразумевается метод `btree`.

_`имя_столбца`_

Имя столбца таблицы.

_`выражение`_

Выражение с одним или несколькими столбцами таблицы. Обычно выражение должно записываться в скобках, как показано в синтаксисе команды. Однако скобки можно опустить, если выражение записано в виде вызова функции.

_`правило_сортировки`_

Имя правила сортировки, применяемого для индекса. По умолчанию используется правило сортировки, заданное для индексируемого столбца, либо полученное для результата выражения индекса. Индексы с нестандартными правилами сортировки могут быть полезны для запросов, включающих выражения с такими правилами.

_`класс_операторов`_

Имя класса операторов. Подробнее об этом ниже.

`ASC`

Указывает порядок сортировки по возрастанию (подразумевается по умолчанию).

`DESC`

Указывает порядок сортировки по убыванию.

`NULLS FIRST`

Указывает, что значения NULL после сортировки оказываются перед остальными. Это поведение по умолчанию с порядком сортировки `DESC`.

`NULLS LAST`

Указывает, что значения NULL после сортировки оказываются после остальных. Это поведение по умолчанию с порядком сортировки `ASC`.

_`параметр_хранения`_

Имя специфичного для индекса параметра хранения. За подробностями обратитесь к [Параметры хранения индекса](https://postgrespro.ru/docs/postgresql/9.6/sql-createindex#sql-createindex-storage-parameters "Параметры хранения индекса").

_`табл_пространство`_

Табличное пространство, в котором будет создан индекс. Если не определено, выбирается [default_tablespace](https://postgrespro.ru/docs/postgresql/9.6/runtime-config-client#guc-default-tablespace), либо [temp_tablespaces](https://postgrespro.ru/docs/postgresql/9.6/runtime-config-client#guc-temp-tablespaces), при создании индекса временной таблицы.

_`предикат`_

Выражение ограничения для частичного индекса.