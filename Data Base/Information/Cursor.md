Вместо того, чтобы выполнять весь запрос сразу, можно настроить _курсор_ , который инкапсулирует запрос, а затем считывать результат запроса по несколько строк за раз. Одна из причин для этого — избежать переполнения памяти, когда результат содержит большое количество строк. (Однако пользователям PL/pgSQL обычно не нужно беспокоиться об этом, поскольку `FOR`циклы автоматически используют курсор внутри, чтобы избежать проблем с памятью.) Более интересное использование — возврат ссылки на курсор, созданный функцией, что позволяет вызывающему объекту считывать строки. Это обеспечивает эффективный способ возврата больших наборов строк из функций.

### Что такое курсоры в PostgreSQL?

Курсоры в PostgreSQL — это механизм, позволяющий работать с результатами выполнения запроса построчно, вместо обработки всего набора данных сразу. Курсор можно представить как "указатель", который перемещается по строкам результата запроса.

---

### Зачем нужны курсоры?

1. **Работа с большими объемами данных**:
    
    - Если запрос возвращает много строк, то обработка всех данных сразу может занять много памяти. Курсоры позволяют обрабатывать данные постепенно.
2. **Гибкость при обработке данных**:
    
    - Курсоры дают возможность программно управлять получением и обработкой строк результата. Это особенно полезно в хранимых процедурах и функциях.
3. **Пошаговая обработка данных**:
    
    - Можно выполнять сложные логические операции над каждой строкой результата поочередно.

---

### Как использовать курсоры?

Курсоры используются обычно в хранимых процедурах или функциях в PL/pgSQL (процедурный язык PostgreSQL). Вот основные этапы работы с курсорами:

#### 1. **Объявление курсора**

Курсор объявляется с помощью команды `DECLARE`:

`DECLARE cursor_name CURSOR FOR query;`

Пример:

`DECLARE my_cursor CURSOR FOR  SELECT product_id, product_name, price FROM products WHERE price > 1000;`

---

#### 2. **Открытие курсора**

Чтобы курсор начал возвращать строки, его нужно открыть:

`OPEN cursor_name;`

---

#### 3. **Извлечение данных из курсора**

Для получения строк используется команда `FETCH`:

`FETCH [NEXT | PRIOR | FIRST | LAST | ABSOLUTE n | RELATIVE n] FROM cursor_name;`

Пример:

`FETCH NEXT FROM my_cursor;`

Это извлекает следующую строку из результата.

---

#### 4. **Цикл для обработки строк**

Курсоры часто используются в циклах для обработки всех строк результата:

`LOOP     FETCH NEXT FROM my_cursor INTO var1, var2, var3;     EXIT WHEN NOT FOUND; -- Выход из цикла, если строки закончились     -- Обработка строки END LOOP;`

---

#### 5. **Закрытие курсора**

После завершения работы курсор нужно закрыть:

`CLOSE cursor_name;`

---

### Полный пример использования курсора

Допустим, есть таблица `products`, и нам нужно для каждого продукта с ценой > 1000 выполнить некоторые действия.

	DO $$
	DECLARE
	    product_id INTEGER;
	    product_name TEXT;
	    product_price NUMERIC;
	    my_cursor CURSOR FOR 
	        SELECT product_id, product_name, price 
	        FROM products 
	        WHERE price > 1000;
	BEGIN
	    -- Открываем курсор
	    OPEN my_cursor;
	
	    -- Извлекаем строки курсора в цикле
	    LOOP
	        FETCH NEXT FROM my_cursor INTO product_id, product_name, product_price;
	        EXIT WHEN NOT FOUND; -- Выходим, если строк больше нет
	
	        -- Логика обработки строки
	        RAISE NOTICE 'Product: %, Price: %', product_name, product_price;
	    END LOOP;
	
	    -- Закрываем курсор
	    CLOSE my_cursor;
	END $$;


---

### Типы курсоров

1. **Имя курсора**:
    
    - Самый простой курсор, объявленный явно.
2. **Параметризованный курсор**:
    
    - Можно передавать параметры в курсор при его объявлении. Например:
        
        `DECLARE param_cursor CURSOR (min_price NUMERIC) FOR  SELECT * FROM products WHERE price > min_price;`
        
3. **Системные курсоры**:
    
    - Автоматически создаются PostgreSQL при использовании команд `FOR` или `FOREACH`.

---

### Ограничения курсоров

1. **Не работает вне транзакции**:
    
    - Курсоры должны быть открыты и использованы внутри транзакции. Например:
        
        `BEGIN; DECLARE my_cursor CURSOR FOR SELECT * FROM products; FETCH NEXT FROM my_cursor; CLOSE my_cursor; COMMIT;`
        
2. **Медленнее, чем стандартные запросы**:
    
    - Если можно выполнить запрос целиком, курсоры использовать не стоит, так как они увеличивают накладные расходы.
3. **Могут быть неэффективны для большого количества данных**:
    
    - При неправильном использовании могут снизить производительность.

---

### Пример с динамическим SQL и курсорами

Иногда нужно объявить курсор для динамического SQL-запроса:

	DO 
	DECLARE
	    dyn_cursor REFCURSOR;
	    row_data RECORD;
	BEGIN
	    -- Динамическое создание курсора
	    OPEN dyn_cursor FOR EXECUTE 'SELECT * FROM products WHERE price > 1000';
	
	    -- Извлечение данных
	    LOOP
	        FETCH dyn_cursor INTO row_data;
	        EXIT WHEN NOT FOUND;
	        RAISE NOTICE 'Product: %', row_data.product_name;
	    END LOOP;
	
	    -- Закрываем курсор
	    CLOSE dyn_cursor;
	END ;


---

### Заключение

**Курсоры** удобны для обработки данных по строкам, особенно в хранимых процедурах и функциях. Они помогают обрабатывать большие объемы данных пошагово, избегая больших объемов памяти. Однако, при неправильном использовании могут замедлить работу базы данных. Используйте их только там, где это действительно необходимо!