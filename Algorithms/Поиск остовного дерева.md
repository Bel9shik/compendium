G = {V, E}

Остов: T $\in$ G | T - дерево, $\sum w_e \in$ T -> min  

## Идея алгоритма Краскала

Смотри на минимальные веса рёбер, если же ребро не принадлежит тому дереву, которое мы строим, то добавляем его в наше дерево. Пройдясь по увеличению весов  в графе получим минимальный остов.

### Пример

Пример графа: (первые два столбика номера вершин, третий - вес ребра)
6 9
1 2 5
3 4 2
3 2 8
4 6 1
6 6 3
5 2 4
1 4 7
6 3 3
3 8 1

![[Pasted image 20250316101830.png]]

Разбор работы алгоритма на этом примере:

Отсортировываем рёбра по весам

$7$ 1 2 5
$3$ 3 4 2
$9$ 3 2 8
$1$ 4 6 1
$4$ 6 6 3
$6$ 5 2 4
$8$ 1 4 7
$5$ 6 3 3
$2$ 3 8 1

Добавляем в дерево рёбра с минимальным весом, которые не связаны
Используем номера рёбер (первый столбик): 1,2, 3, 6, 7. Остальные номера не берём.
![[Pasted image 20250316103607.png]]


### Реализация

Нужен какой-то массив для хранения массив айдишников деревьев

	int tree_id[MAXN];
	for (int i = 0; i < n; i++) {
			tree_id[i] = i;
	}


	vector<pair<int, pair<int, int>>> g; //первый int - вес, вторая пара - номера вершин
	sort(g.begin(), g.end());


	vector <pair<int, int>> res;
	int cost = 0;
	for (int i = 0; i < m;i++) { //m -чилос рёбер
		int w = g[i].first;
		int u = g[i].second.first;
		int u = g[i].second.second;
		if (tree_id[u] != tree_id[v]) {
			for (int j = 0; i < n; j++) {
				if (tree_id[j] == tree_id[u]) {
				tree_id[j] = tree_id[v]
				}
			}
		}
		res.push_back(g[v].second);
		cost += w;
	}

Сложность: (MlogM + $N^2$)

Т.к. "перекрашиваение" работает за квадрат, то попробуем это оптимизировать

### Структура DSU (СНМ на русском. Система непересекающихся множеств)

Есть какая-то структура, которая поддерживает 3 операции:
	void make(int*)  - создаёт дерево
	int get(int x) - выдаёт представителя
	void union(int a, int b) - объединение множеств

#### Реализация:

	int parent[MAXN] - хранить айди предков

	void make(int *) {
		parent[x] x;
		size[x] = 1;
	}

	int get(int x) {
		if (parent[x] == x) {
			return x;
		} else {
			return parent[x] = get(parent[x]);
		}
	}

	void union(int a, int b) {
		int u = get(a);
		int v = get(b);
		
		if (u != v) {
			parent[v] = u;
		}
	}
Сложность: O(logN)

Вторая реализация (улучшенная). Идея в том, что маленькое дерево подвешиваем к большому и боримся за балансированность дерева.

	void size[MAXN];

	void union (int a, int b) {
		int u = get(a);
		int v = get(b);
		int sz_u = size[u];
		int sz_v = size[v];
		if (sz_u < sz_v) {
			swap (u, v);
		}
		if (u != v) {
			parent[v] = u;
			size[u] += sz_v;
		}
	}

Сложность: O ($\alpha$(N) ), где $\alpha$ - функция Аккермана. Она ООООООООЧЕНЬ медленно растёт (пример: $\alpha(10^{6000})$ = 4). Так что работа алгоритма практически константа

Перепишем алгоритм с использованием СНМ:

	for (int i = 0; i < n; i++) {
		make(i);
	}

	vector <pair<int, int>> res;
	int cost = 0;
	for (int i = 0; i < m; i++) {
		int w = g[i].first;
		int u = g[i].second.first;
		int u = g[i].second.second;
		
		if (get(u) != get(v)) {
			unioin (u, v);
			res.push_back(g[v].second);
			cost += w;
		}

	}
Сложность: O(MlogM + M) = O(MlogM)

## Алгоритм Прима

### Идея

Начинаем с вершины, смотрим на ребро с мин. весом, если вершина с другой стороны ребра не в дереве, то добавляем в наше дерево и так по всем ново-добавленным вершинам. Добавляем в дерево и смотрим на минимальный вес прилешающих рёбер